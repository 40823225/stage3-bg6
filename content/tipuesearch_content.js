var tipuesearch = {"pages": [{'title': 'About', 'text': '小組個人成員倉儲/ 小組個人成員網頁 \n 40823211 /40823211 \xa0陳昱愷 \n 40823214 / 40823214 \xa0 林厚宇 \n 40823216 /40823216 \xa0 陳弘勛 \n 40823218 /40823218 \xa0 陳致文 \n 40823225 /40823225 \xa0 徐誠隆\xa0 \n 40823238 /40823238 \xa0 吳容輝 \n 40823247 /40823247 \xa0 許力右 \n 40823248 /40823248 \xa0 劉彥廷', 'tags': '', 'url': 'About.html'}, {'title': '機械手臂', 'text': '原本我們的主題，是在我們原本在stage2-bg6所做的腳踏車衝擊測試機跟機械手臂在做選擇，但考慮到 腳踏車衝擊測試機的零件數過多及他所會遇到的力學相關的問題，所以我們最後討論出來的結果是，將主題訂為機械手臂。 \n', 'tags': '', 'url': '機械手臂.html'}, {'title': '繪圖成果', 'text': '此為不含夾爪有六軸的機械手臂 \n \n', 'tags': '', 'url': '繪圖成果.html'}, {'title': '計算角度', 'text': '\n 計算到達指定位置馬達所需選轉的角度 \n 步驟1 \n 需要先知道各個零件的尺寸 \n \n 可以得以下算式 \n \n 步驟2 \n 透過以下計算先將底座旋轉到目標與中心平面 \n \n \n 步驟3 \n 取得新的X位置 \n \n \n 步驟4 \n 取得目標物與旋轉中心的相對位置 \n 注 因吸盤保持水平 所以可以忽略其相對位置 \n \n \n 步驟5 \n 透過海龍公式(略) 可以得到面積 \n 知道面積可求三角形之高 \n \n \n 步驟6 \n 旋轉基座馬達 但是需要減去原有的角度 \n \n \n 步驟7 \n 旋轉2臂 \n \n \n 步驟8 \n 旋轉夾具\xa0 \n 注:因演示所以排在最後面，在實際作動時須排在第一位移動避免撞機 \n \n \n', 'tags': '', 'url': '計算角度.html'}, {'title': '程式模擬', 'text': '', 'tags': '', 'url': '程式模擬.html'}, {'title': 'W10', 'text': '上網找的資料顯示coppeliasim上有一個編輯程式的選項 \n 參考資料: https://zhuanlan.zhihu.com/p/105960079 \n 4/27(二)因為繪圖部分還沒畫好，今天暫時用coppeliasim裡的機械手臂模型來模擬。 \n 設定的主體上連結每個零件，各零件之間有可以旋轉的軸，以及連結的命令區塊 \n 下圖為參考的機械手臂: \n \n 這是機械手臂的零件圖: \n \n', 'tags': '', 'url': 'W10.html'}, {'title': 'W11', 'text': '根據上網找的資料，發現COPPELIASIM的程式編譯語言為LUA，但仍可透過改變設定，來使用其他語言編譯。 \n \n 以下為參考資料: \n https://blog.csdn.net/qq_29696095/article/details/104406971 https://blog.csdn.net/qq_29696095/article/details/104474081 https://www.coppeliarobotics.com/helpFiles/en/inverseKinematicsTutorial.htm \n http://mde.tw/cd2021/downloads/V-REP%20Lecture.pdf http://hades.mech.northwestern.edu/index.php/CoppeliaSim_Introduction https://www.coppeliarobotics.com/helpFiles/index.html http://mde.tw/cd2021/content/V-rep.html \n', 'tags': '', 'url': 'W11.html'}, {'title': 'CoppliaSim程式模擬', 'text': '', 'tags': '', 'url': 'CoppliaSim程式模擬.html'}, {'title': 'CoppeliaSim 教學', 'text': '', 'tags': '', 'url': 'CoppeliaSim 教學.html'}, {'title': '軸的旋轉教學', 'text': "\n 程式碼 \n function sysCall_init()\n    -- do some initialization here\n    joint=sim.getObjectHandle('joint01')\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    sim.setJointTargetPosition(joint,135*math.pi/180)\nend \n", 'tags': '', 'url': '軸的旋轉教學.html'}, {'title': '直線運動教學', 'text': "\n 程式指令 \n function sysCall_init()\n    -- do some initialization here\n    joint=sim.getObjectHandle('joint')\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    sim.setJointTargetPosition(joint,50)\nend \n", 'tags': '', 'url': '直線運動教學.html'}, {'title': '1-單軸直線運動', 'text': "\n 程式碼 \n function sysCall_init()\n    -- do some initialization here\n    joint=sim.getObjectHandle('joint')\n    set=0\nend\n \nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if(message==sim.message_keypress)then\n            if(auiliaryData[1]==2009)then\n                set=set+0.01\n                sim.setJointTargetPosition(joint,set)\n            end\n        end\n    message,auiliaryData=sim.getSimulatorMessage()\n    end\nend \n \n", 'tags': '', 'url': '1-單軸直線運動.html'}, {'title': '2-可變速之旋轉運動', 'text': "\n 程式碼\xa0 (注:下方程式碼有修改 degset(每次旋轉的角度)不會小於1 \n function sysCall_init()\n    -- do some initialization here\n    joint=sim.getObjectHandle('joint')\n    set=0\n    degset=1\nend\n \nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2009) then\n            set=set+degset\n            sim.setJointTargetPosition(joint,set*math.pi/180)\n            end\n            if (auxiliaryData[1]==2010) then\n            set=set-degset\n            sim.setJointTargetPosition(joint,set*math.pi/180)\n            end\n            if (auxiliaryData[1]==2007) then\n                degset=degset+5\n                print(degset)\n            end\n            if (auxiliaryData[1]==2008) then\n                degset=degset-5\n                if(degset<1) then\n                    degset=1\n                end\n                print(degset)\n            end\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend\n     \n", 'tags': '', 'url': '2-可變速之旋轉運動.html'}, {'title': '3-遙控攝影小汽車', 'text': "\n 範例程式碼 \n function sysCall_init()\n    -- do some initialization here\n    f=sim.getObjectHandle('F')\n    r=sim.getObjectHandle('R')\n    speedf=10\n    speedr=10\n    Cam1=sim.getObjectHandle('Camera')\n    CamView1=sim.floatingViewAdd(0.2,0.8,0.5,0.5,0)\n    sim.adjustView(CamView1,Cam1,64)\nend\n\nfunction sysCall_cleanup() \n    sim.floatingViewRemove(CamView1)\nend \n \nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2007) then\n                speedf=speedf-30\n                speedr=speedr-30\n                sim.setJointTargetPosition(f,speedf*math.pi/180)\n                sim.setJointTargetPosition(r,speedr*math.pi/180)\n            end\n            if (auxiliaryData[1]==2008) then\n                speedf=speedf+30\n                speedr=speedr+30\n                sim.setJointTargetPosition(f,speedf*math.pi/180)\n                sim.setJointTargetPosition(r,speedr*math.pi/180)\n            end\n            if (auxiliaryData[1]==2009) then\n                speedr=speedr-30\n                sim.setJointTargetPosition(r,speedr*math.pi/180)\n            end\n            if (auxiliaryData[1]==2010) then\n                speedf=speedf-30\n                sim.setJointTargetPosition(f,speedf*math.pi/180)\n            end\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend \n \n", 'tags': '', 'url': '3-遙控攝影小汽車.html'}, {'title': 'CODE 指令解說', 'text': '部分LUA指令講解 \n 1.sim.getObjectHandle \n 使用範例如下 \n XXX=sim.getObjectHandle(\'joint\') \n 講解 XXX為一個自行定義的名詞，此指令為定義XXX為一個連接軸，而(\'joint\')為該軸在場景裡面的名稱 \n \n 2.sim.setJointTargetPosition \n 使用範例如下 \n sim.setJointTargetPosition(XXX,90) \n 講解 XXX移動至90這個位置，或旋轉至90rad，XXX請參見第一個指令講解,角度預設為RAD \n 若要需求為旋轉至90deg，指令參考如下 \n sim.setJointTargetPosition(XXX,90*math.pi/180) \n \n 3.sim.getSimulatorMessage \n 使用範例如下 \n message,auxiliaryData=sim.getSimulatorMessage()\nwhile message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2009) then\n               指定要做的事情\n            end\n         end\nmessage,auxiliaryData=sim.getSimulatorMessage()\nend\n \n \n 講解 \n 第一行 \n message,auxiliaryData=sim.getSimulatorMessage() \n message代表跟鍵盤對接的狀態 \n auxiliaryData代表讀取到鍵盤的值 \n 第二行的開始 \n 當(while)"message的值不等於-1時 \n 若(if) auxiliaryData讀取到的值為2009 \n 進行要做的事情，可以是上面第二項"sim.setJointTargetPosition"或其他指令 \n 可參考 尋找控制代碼 \n \n 4.simwat \n 使用範例 \n sim.wait(0.01) \n 只能在線程控制中使用(Threaded chil script) \n 為暫停指令，括弧內單位為秒 \n', 'tags': '', 'url': 'CODE 指令解說.html'}, {'title': 'remoteApi python 指令對照', 'text': '1.simxGetObjectHandle \n ret,XXX=vrep.simxGetObjectHandle(clientID,"joint",opmode) \n XXX為一個自行定義的名詞，此指令為定義XXX為一個連接軸，而(\'joint\')為該軸在場景裡面的名稱 \n 與Lua語法類似 \n 2.simxSetJointTargetPosition \n  vrep.simxSetJointTargetPosition(clientID,XXX,90,opmode) \n 講解 XXX移動至90這個位置，或旋轉至90rad，XXX請參見第一個指令講解,角度預設為RAD \n 若要需求為旋轉至90deg，指令參考如下 \n 與Lua語法類似 \n', 'tags': '', 'url': 'remoteApi python 指令對照.html'}, {'title': '機械手臂設定範例', 'text': '\n \n', 'tags': '', 'url': '機械手臂設定範例.html'}, {'title': '按鍵控制代碼', 'text': "\n \n \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n \n \n a \n 97 \n j \n 106 \n s \n 115 \n 0 \n 48 \n 9 \n 57 \n . \n 46 \n \n \n b \n 98 \n k \n 107 \n t \n 116 \n 1 \n 49 \n + \n 43 \n ; \n 59 \n \n \n c \n 99 \n l \n 108 \n u \n 117 \n 2 \n 50 \n - \n 45 \n ' \n 39 \n \n \n d \n 100 \n m \n 109 \n v \n 118 \n 3 \n 51 \n * \n 42 \n [ \n 91 \n \n \n e \n 101 \n n \n 110 \n w \n 119 \n 4 \n 52 \n / \n 47 \n ] \n 93 \n \n \n f \n 102 \n o \n 111 \n x \n 120 \n 5 \n 53 \n = \n 61 \n 方向鍵上 \n 2007 \n \n \n g \n 103 \n p \n 112 \n y \n 121 \n 6 \n 54 \n ` \n 96 \n 方向鍵下 \n 2008 \n \n \n h \n 104 \n q \n 113 \n z \n 122 \n 7 \n 55 \n \\ \n 92 \n 方向鍵左 \n 2009 \n \n \n i \n 105 \n r \n 114 \n 空白鍵 \n 32 \n 8 \n 56 \n , \n 44 \n 方向鍵右 \n 2010 \n \n \n \n \n", 'tags': '', 'url': '按鍵控制代碼.html'}, {'title': '架設場景', 'text': '', 'tags': '', 'url': '架設場景.html'}, {'title': '對軸進行旋轉控制', 'text': '使用coppeliaSim\xa0先叫出一個簡單的軸 \n 來進行模擬控制 \n \n \n', 'tags': '', 'url': '對軸進行旋轉控制.html'}, {'title': '對方快進行XYZ軸控制', 'text': "\n 建立方塊並且對其進行XYZ軸控制 \n \n \n 程式碼如下 \n function sysCall_init()\n    joint01=sim.getObjectHandle('joint01')\n    joint02=sim.getObjectHandle('joint02')\n    joint03=sim.getObjectHandle('joint03')\n    set=0\n    set1=0\n    set2=0\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2009) then\n                set=set+0.01\n                sim.setJointTargetPosition(joint01,set)\n            end\n            if (auxiliaryData[1]==2010) then\n                set=set-0.01\n                sim.setJointTargetPosition(joint01,set)\n            end\n            if (auxiliaryData[1]==2007) then\n               set1=set1+0.01\n               sim.setJointTargetPosition(joint02,set1)\n            end\n           if (auxiliaryData[1]==2008) then\n              set1=set1-0.01\n              sim.setJointTargetPosition(joint02,set1)\n            end\n            if (auxiliaryData[1]==50) then\n               set2=set2+0.01\n               sim.setJointTargetPosition(joint03,set2)\n            end\n           if (auxiliaryData[1]==56) then\n              set2=set2-0.01\n              sim.setJointTargetPosition(joint03,set2)\n            end\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend \n \n", 'tags': '', 'url': '對方快進行XYZ軸控制.html'}, {'title': '物件螺旋運動', 'text': "使用現成 腳本使方塊進行螺旋運動 \n \n code \n function sysCall_threadmain()\n    jointx=sim.getObjectHandle('01')\n    jointy=sim.getObjectHandle('02')\n    jointz=sim.getObjectHandle('03')\n    high=0\n    \n    for cycle=0,36000,1 do\n        sim.setJointTargetPosition(jointx,0.3*(math.sin(cycle*math.pi/180)))\n        sim.wait(0.01)\n        sim.setJointTargetPosition(jointy,0.3*(math.cos(cycle*math.pi/180)))\n        sim.wait(0.01)\n        high=high+0.001\n        sim.setJointTargetPosition(jointz,high)\n        sim.wait(0.01)\n        \n    end\nend \n \n", 'tags': '', 'url': '物件螺旋運動.html'}, {'title': '3D列印機_控制噴嘴', 'text': "\n 控制: \n 上下左右控制噴頭的上下左右 \n 空白鍵往上 \n C鍵往下 \n \n \n 圖檔下載 \n 3D print.ttt \n \n \n 程式參考 \n function sysCall_init()\n    joint01=sim.getObjectHandle('X')\n    joint02=sim.getObjectHandle('Y')\n    joint03=sim.getObjectHandle('Z')\n    set=0\n    set1=0\n    set2=0\n    s=0.005\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2009) then\n                set=set+s\n                sim.setJointTargetPosition(joint01,set)\n                print(sim.getJointPosition(joint01))\n            end\n            if (auxiliaryData[1]==2010) then\n                set=set-s\n                sim.setJointTargetPosition(joint01,set)\n            end\n            if (auxiliaryData[1]==2007) then\n               set1=set1+s\n               sim.setJointTargetPosition(joint02,set1)\n            end\n           if (auxiliaryData[1]==2008) then\n              set1=set1-s\n              sim.setJointTargetPosition(joint02,set1)\n            end\n            if (auxiliaryData[1]==32) then\n               set2=set2+s\n               sim.setJointTargetPosition(joint03,set2)\n            end\n           if (auxiliaryData[1]==99) then\n              set2=set2-s\n              sim.setJointTargetPosition(joint03,set2)\n            end\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend \n \n", 'tags': '', 'url': '3D列印機_控制噴嘴.html'}, {'title': '3D列印機_自動繪製', 'text': "自動繪製正方體 \n 3D print AutoControl cube.ttt \n 自動繪製圓柱體 \n 3D print AutoControl circle.ttt \n 自動繪製心臟線 \n 3D print AutoControl Cardioid.ttt \n 參考影片 \n \n 程式參考: \n 1.正方體 \n find_Position=function()\nXYZ={xp, yp, zz, step}\nend\nfunction sysCall_threadmain()\n    joint01=sim.getObjectHandle('X')\n    joint02=sim.getObjectHandle('Y')\n    joint03=sim.getObjectHandle('Z')\n    grap=sim.getObjectHandle('Graph')\n    set=0\n    set1=0\n    set2=0\n    s=0.01\n    step=1\n    xp=0\n    yp=0\n    zz=0\n    xstep=0\n    ystep=0\n    zstep=0\n    cubesize=10\n    t=1\n    \n    \n    while zstep<=cubesize do\n        while step<cubesize do --go++\n            while xstep<=step do\n                xp=xp+s\n                sim.setJointTargetPosition(joint01,xp)\n                find_Position()\n                print(XYZ)\n                xstep=xstep+1\n                sim.wait(t)\n            end\n            while ystep<=step do\n                yp=yp+s\n                sim.setJointTargetPosition(joint02,yp)\n                find_Position()\n                print(XYZ)\n                ystep=ystep+1\n                sim.wait(t)\n            end\n            --step=step+1\n            xstep=0\n            ystep=0    \n            while xstep<=step do\n                xp=xp-s\n                sim.setJointTargetPosition(joint01,xp)\n                find_Position()\n                print(XYZ)\n                xstep=xstep+1\n                sim.wait(t)\n            end\n            while ystep<=step do --go--\n                yp=yp-s\n                sim.setJointTargetPosition(joint02,yp)\n                find_Position()\n                print(XYZ)\n                ystep=ystep+1\n                sim.wait(t)\n            end\n            if step < (cubesize-1) then\n                xp=xp-0.5*s\n                yp=yp-0.5*s\n                sim.setJointTargetPosition(joint01,xp)\n                sim.setJointTargetPosition(joint02,yp)\n                find_Position()\n                print(XYZ)\n            end\n            step=step+1\n            sim.wait(t)\n            xstep=0\n            ystep=0\n        end\n        step=1\n        zz=zz+s\n        sim.setJointTargetPosition(joint03,zz)\n        find_Position()\n        print(XYZ)\n        zstep=zstep+1\n        sim.wait(t)\n        xp=0\n        yp=0\n        sim.setJointTargetPosition(joint01,xp)\n        sim.setJointTargetPosition(joint02,yp)\n        find_Position()\n        print(XYZ)\n        sim.wait(t)\n    end\n    \nend\n\nfunction sysCall_cleanup()\n      \n    \nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n 2. 圓柱體 \n function sysCall_threadmain()\n    joint01=sim.getObjectHandle('X')\n    joint02=sim.getObjectHandle('Y')\n    joint03=sim.getObjectHandle('Z')\n    grap=sim.getObjectHandle('Graph')\n    set=0\n    set1=0\n    set2=0\n    s=0.01\n    step=1\n    r=0.005\n    rset=0.01\n    zz=0\n    zstep=1\n    dz=0.01\n    rstep=1\n    cubesize=10\n    t=0.01\n    angle=0\n    angleset=2\n    \nend\n\nfunction sysCall_cleanup()\n    while zstep<=20 do\n        while rstep<=5 do\n            while angle~=360 do\n                angle=angle+angleset\n                sim.setJointTargetPosition(joint01,r*(math.sin(angle*math.pi/180)))\n                sim.setJointTargetPosition(joint02,r*(math.cos(angle*math.pi/180)))\n                sim.wait(t)\n            end\n        rstep=rstep+1\n        angle=0\n        r=r+rset\n        print(rstep)\n        end\n    zz=zz+dz\n    zstep=zstep+1\n    sim.setJointTargetPosition(joint03,zz)\n    sim.setJointTargetPosition(joint01,0)\n    sim.setJointTargetPosition(joint02,0)\n    rstep=1\n    r=0.005\n    end\n    \nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n 3. 心臟線 \n function sysCall_threadmain()\n    joint01=sim.getObjectHandle('X')\n    joint02=sim.getObjectHandle('Y')\n    joint03=sim.getObjectHandle('Z')\n    grap=sim.getObjectHandle('Graph')\n    set=0\n    set1=0\n    set2=0\n    s=0.01\n    step=1\n    r=0.005\n    rset=0.001\n    zz=0\n    zstep=1\n    dz=0.001\n    rstep=1\n    cubesize=10\n    t=0.5\n    angle=0\n    angleset=2\n    \nend\n\nfunction sysCall_cleanup()\n    while zstep<=30 do\n        while rstep<=30 do\n            while angle~=360 do\n                angle=angle+angleset\n                sim.setJointTargetPosition(joint01,2*r*((math.cos(angle*math.pi/180))-0.5*(math.cos(2*angle*math.pi/180))))\n                sim.setJointTargetPosition(joint02,2*r*((math.sin(angle*math.pi/180))-0.5*(math.sin(2*angle*math.pi/180))))\n                sim.wait(t)\n            end\n        rstep=rstep+1\n        angle=0\n        r=r+rset\n        print(rstep)\n        end\n    zz=zz+dz\n    zstep=zstep+1\n    sim.setJointTargetPosition(joint03,zz)\n    sim.setJointTargetPosition(joint01,0)\n    sim.setJointTargetPosition(joint02,0)\n    rstep=1\n    r=0.005\n    end\n    \nend\n\n \n \n", 'tags': '', 'url': '3D列印機_自動繪製.html'}, {'title': '3D列印機_控制高度', 'text': "\n 控制: \n 上下左右控制噴頭的上下左右 \n 空白鍵往上 \n C鍵往下 \n \n \n 圖檔下載 \n 3D print control altitude.ttt \n \n 影片參考 \n \n 程式參考: \n function sysCall_init()\n    -- do some initialization here\n    joint1=sim.getObjectHandle('P1')\n    joint2=sim.getObjectHandle('P2')\n    joint3=sim.getObjectHandle('P3')\n    xp=0\n    yp=0\n    zp=0\n    p1p=0\n    p2p=0\n    p3p=0\n    dz=0\n    step=0.01\n    --sim.getJointTargetPosition(joint1,p1p)\n    --sim.getJointTargetPosition(joint2,p2p)\n    --sim.getJointTargetPosition(joint3,p3p)\n    H=((0.290)^2-(0.1325)^2)^(1/2)\n    BaseX=0.1325*(math.cos(60*math.pi/180))\n    BaseY2=0.1325*(math.sin(60*math.pi/180))\n    BaseY3=0.1325*(math.sin(60*math.pi/180))\nend\n\nxyz = function()\n    bar1=(((0.290)^2-(0.1325-xp)^2-yp^2)^(1/2)-H+dz)\n    bar2=(((0.290)^2-BaseX^2-BaseY2^2)^(1/2)-H+dz)\n    bar3=(((0.290)^2-BaseX^2-BaseY3^2)^(1/2)-H+dz)\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2010) then\n                xp=xp+step\n                BaseX=BaseX+step\n                xyz()\n                sim.setJointTargetPosition(joint1,bar1)\n                sim.setJointTargetPosition(joint2,bar2)\n                sim.setJointTargetPosition(joint3,bar3)\n            end\n            if (auxiliaryData[1]==2009) then\n                xp=xp-step\n                BaseX=BaseX-step\n                xyz()\n                sim.setJointTargetPosition(joint1,bar1)\n                sim.setJointTargetPosition(joint2,bar2)\n                sim.setJointTargetPosition(joint3,bar3)\n            end\n            if (auxiliaryData[1]==2007) then\n                yp=yp+step\n                BaseY2=BaseY2-step\n                BaseY3=BaseY3+step\n                xyz()\n                sim.setJointTargetPosition(joint1,bar1)\n                sim.setJointTargetPosition(joint2,bar2)\n                sim.setJointTargetPosition(joint3,bar3)\n            end\n            if (auxiliaryData[1]==2008) then\n                yp=yp-step\n                BaseY2=BaseY2+step\n                BaseY3=BaseY3-step\n                xyz()\n                sim.setJointTargetPosition(joint1,bar1)\n                sim.setJointTargetPosition(joint2,bar2)\n                sim.setJointTargetPosition(joint3,bar3)\n            end\n            if (auxiliaryData[1]==32) then\n                sim.getJointTargetPosition(joint1,p1p)\n                sim.getJointTargetPosition(joint2,p2p)\n                sim.getJointTargetPosition(joint3,p3p)\n                p1p=p1p+dz\n                p2p=p2p+dz\n                p3p=p3p+dz\n                dz=dz+step\n                printf(p1p)\n                xyz()\n                print(p2p)\n                sim.setJointTargetPosition(joint1,bar1+dz)\n                sim.setJointTargetPosition(joint2,bar2+dz)\n                sim.setJointTargetPosition(joint3,bar3+dz)\n                H=H-dz\n            end\n            if (auxiliaryData[1]==99) then\n                sim.getJointTargetPosition(joint1,p1p)\n                sim.getJointTargetPosition(joint2,p2p)\n                sim.getJointTargetPosition(joint3,p3p)\n                p1p=p1p-dz\n                p2p=p2p-dz\n                p3p=p3p-dz\n                dz=dz-step\n                printf(p1p)\n                xyz()\n                print(p2p)\n                sim.setJointTargetPosition(joint1,bar1-dz)\n                sim.setJointTargetPosition(joint2,bar2-dz)\n                sim.setJointTargetPosition(joint3,bar3-dz)\n                H=H-dz\n            end\n         end\nmessage,auxiliaryData=sim.getSimulatorMessage()\nend\n    \nend\n\nfunction sysCall_sensing()\n    -- put your sensing code here\nend\n\nfunction sysCall_cleanup()\n    -- do some clean-up here\nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n \n \n", 'tags': '', 'url': '3D列印機_控制高度.html'}, {'title': '衝擊試驗機', 'text': "控制說明 \n 請依序按下1~4 \n 分別為上升、落下、往下、接合 \n \n \n 程式碼參考 \n function sysCall_init()\n    -- do some initialization here\n    jointY=sim.getObjectHandle('Prismatic_joint')\n    joint1=sim.getObjectHandle('Prismatic_joint0')\n    joint2=sim.getObjectHandle('Prismatic_joint1')\n    cont=1\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==49) then\n                if (cont==1) then\n                    sim.setJointTargetPosition(jointY,40)\n                    cont=2\n                end\n            end\n            if (auxiliaryData[1]==50) then\n                if (cont==2) then\n                    sim.setJointTargetPosition(joint1,0.1)\n                    sim.setJointTargetPosition(joint2,-0.1)\n                    cont=3\n                end\n            end\n            if (auxiliaryData[1]==51) then\n                if (cont==3) then\n                    sim.setJointTargetPosition(jointY,0)\n                    cont=4\n                end\n            end\n            if (auxiliaryData[1]==52) then\n                if (cont==4) then\n                    sim.setJointTargetPosition(joint1,0)\n                    sim.setJointTargetPosition(joint2,0)\n                    cont=1\n                end\n            end\n         end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend\n\nfunction sysCall_sensing()\n    -- put your sensing code here\nend\n\nfunction sysCall_cleanup()\n    -- do some clean-up here\nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n \n", 'tags': '', 'url': '衝擊試驗機.html'}, {'title': '架設機械手臂場景', 'text': '將所有物件控制後直接進行模擬，檢測是否有異樣 \n \n', 'tags': '', 'url': '架設機械手臂場景.html'}, {'title': '機械手臂場景微調', 'text': '嘗試使用程式控制 \n 但是還是會亂跑 \n \n \n \n', 'tags': '', 'url': '機械手臂場景微調.html'}, {'title': '機械手臂場景路徑控制', 'text': '勉強可以控制路徑了(預先設定 \n \n \n', 'tags': '', 'url': '機械手臂場景路徑控制.html'}, {'title': 'W13 Pick and Place', 'text': '\n 課程要求 \n \n', 'tags': '', 'url': 'W13 Pick and Place.html'}, {'title': 'remoteApi', 'text': '\n 請見task2-remoteApi->W13 remoteApi \n 傳送門 \n', 'tags': '', 'url': 'remoteApi.html'}, {'title': '0526更新', 'text': '預計更新-remoteApi \n 檔案下載 \n W13_pick and place \n 影片: \n 影片模擬時間為30分鐘，總共進行4次將球放到空盤再回復，理論上可以無限反覆模擬 \n \n 之前在舊版本中，會發現吸盤一直朝同一方向旋轉角度會誤差越來越大，所以在此場景中，將吸取設為正轉，放下設成反轉，即可以避免朝同一方向選轉造成的角度偏移問題 \n 程式構想: \n 透過計算現在為拿取第幾個球，可以推算出該球在第幾層(unit)，也可以定為該層的起始座標(角落) \n 知道在第幾層後可以反推出他是該層的第幾個(finding_XY)，進一步知道他的XY座標(X_Pos/Y_Pos) \n 例: 第九顆球，可以得知在第三層，反推可以得知她是第4個，然後就可以得知她是第二排第一個，以此類推 \n 而在第30顆球過後，需要重新設定基準座標還有重設數量，才有最下面if問句 \n 程式參考 \n function signal_switch(singal,enable)\n    if singal==1 or singal==12 then\n        sim.setIntegerSignal(modelName1 .."call_1",enable)\n    end\n    if singal==2 or singal==11 then\n        sim.setIntegerSignal(modelName2 .."call_2",enable)\n    end\n    if singal==3 or singal==10 then\n        sim.setIntegerSignal(modelName3 .."call_3",enable)\n    end\n    if singal==4 or singal==9 then\n        sim.setIntegerSignal(modelName4 .."call_4",enable)\n    end\n    if singal==5 or singal==8 then\n        sim.setIntegerSignal(modelName5 .."call_5",enable)\n    end\n    if singal==6 or singal==7 then\n        sim.setIntegerSignal(modelName6 .."call_6",enable)\n    end\nend\n\nfunction sysCall_threadmain()\n    joint01=sim.getObjectHandle(\'X\')\n    joint02=sim.getObjectHandle(\'Y\')\n    joint03=sim.getObjectHandle(\'Z\')\n    jointr=sim.getObjectHandle(\'Rotate\')\n    tt=1\n    long_t=1.5\n    long_long_t=3 --time set\n    rotate_deg=0 --pad rotate\n    atz=0  --altitude set\n    setx=0.5\n    setpx=-0.5 --center pick set\n    sety=-0.16\n    setpy=-0.16 --center fall set\n    local pick_high={"0.0645","0.134","0.2025","0.2768"} --pick up high set\n    local fall_high={"0.05","0.12","0.18","0.26"} --fall high set\n    local high_up={"0","0","0.05","0.12"}\n    cube=1              -- set cube\n    ball_pick_time=0    --total ball we pick\n    ball_put_time=31     --total ball we put\n    while (ball_pick_time<60) do\n        for ball=1,6,1 do    --pick the ball\n            ball_pick_time=ball_pick_time+1 --total time we pick\n            i=1\n            unit=0\n            level=0\n            while level < ball_pick_time do  --find which level and place should be of the xy coordinates\n                unit=unit+1\n                level=level+unit^2\n            end\n            finding_XY=ball_pick_time   --this is the XY on that floor\n            while(i<=unit-1) do            \n                finding_XY=finding_XY-(i^2) \n                i=i+1\n            end\n            X_Pos=finding_XY%unit       -- the X and Y coordinates(by balls)\n             if X_Pos==0 then\n                X_Pos=unit\n            end\n            Y_Pos=(math.ceil(finding_XY/unit)) \n            BaseX=setx-((unit-1)*0.05)--now we need to find the 0 of the xy\n            BaseY=sety-((unit-1)*0.05)\n            sim.setJointTargetPosition(joint01,BaseX+(0.1*(X_Pos-1))) --move to Position\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint02,BaseY+(0.1*(Y_Pos-1)))\n            sim.wait(tt)\n            signal_switch(ball,1) --switch pad on\n            sim.setJointTargetPosition(joint03,-pick_high[unit])--pick the pall\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint03,atz-high_up[unit]) --after pick up we dont need to go that high\n            sim.wait(tt)\n            rotate_deg=rotate_deg+60  --rotate the pad\n            sim.setJointTargetPosition(jointr,rotate_deg*math.pi/180)\n            sim.wait(tt)\n            sim.wait(tt)\n        end\n        sim.wait(long_t)\n        sim.setJointTargetPosition(joint01,0)\n        sim.setJointTargetPosition(joint02,0)\n        sim.setJointTargetPosition(joint03,0)\n        sim.wait(long_t)\n        for ball=1,6,1 do --put the ball\n            ball_put_time=ball_put_time-1\n            i=1\n            unit=0\n            level=0\n            while level < ball_put_time do  --find which level and place should be of the xy coordinates\n                unit=unit+1\n                level=level+unit^2\n            end\n            finding_XY=ball_put_time   --this is the XY on that floor\n            while(i<=unit-1) do            \n                finding_XY=finding_XY-(i^2) \n                i=i+1\n            end\n            X_Pos=finding_XY%unit       -- the X and Y coordinates(by balls)\n             if X_Pos==0 then\n                X_Pos=unit\n            end\n            Y_Pos=(math.ceil(finding_XY/unit)) \n            BaseX=setpx-((unit-1)*0.05)--now we need to find the 0 of the xy\n            BaseY=setpy-((unit-1)*0.05)\n            rotate_deg=rotate_deg-60  --rotate the pad\n            sim.setJointTargetPosition(jointr,rotate_deg*math.pi/180)\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint01,BaseX+(0.1*(X_Pos-1))) --move to Position\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint02,BaseY+(0.1*(Y_Pos-1)))\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint03,-fall_high[unit])--pick the pall\n            sim.wait(tt)\n            signal_switch(ball+6,0) --switch pad off\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint03,atz-high_up[unit]) --after pick up we dont need to go that high\n            sim.wait(tt)\n            sim.wait(tt)\n        end\n        sim.wait(long_t)\n        sim.setJointTargetPosition(joint01,0)\n        sim.setJointTargetPosition(joint02,0)\n        sim.setJointTargetPosition(joint03,0)\n        sim.wait(long_t)\n        if ball_pick_time==30 then\n            pick_high={"0.07","0.138","0.2085","0.28"}\n            setx=-setx\n            setpx=-setpx\n            ball_pick_time=0\n            ball_put_time=31\n        end\n    end\nend \n', 'tags': '', 'url': '0526更新.html'}, {'title': '舊版本', 'text': '預計更新內容:將簡化程式碼 \n 圖檔: \n W13 Pick and Place.ttt \n 5/21 拍攝 \n \n \n 程式碼參考 \n 主程式 \n function signal_on()\n    signal_1(true)\n    signal_2(true)\n    signal_3(true)\n    signal_4(true)\n    signal_5(true)\n    signal_6(true)\nend\n\nfunction signal_1(enable)\n    modelBase1=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName1=sim.getObjectName(modelBase1)\n    if enable then\n        sim.setIntegerSignal(modelName1 .."call_1",1)\n    else\n        sim.setIntegerSignal(modelName1 .."call_1",0)\n    end\nend\n\nfunction signal_2(enable)\n    modelBase2=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName2=sim.getObjectName(modelBase2)\n    if enable then\n        sim.setIntegerSignal(modelName2 .."call_2",1)\n    else\n        sim.setIntegerSignal(modelName2 .."call_2",0)\n    end\nend\n\nfunction signal_3(enable)\n    modelBase3=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName3=sim.getObjectName(modelBase3)\n    if enable then\n        sim.setIntegerSignal(modelName3 .."call_3",1)\n    else\n        sim.setIntegerSignal(modelName3 .."call_3",0)\n    end\nend\n\nfunction signal_4(enable)\n    modelBase4=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName4=sim.getObjectName(modelBase4)\n    if enable then\n        sim.setIntegerSignal(modelName4 .."call_4",1)\n    else\n        sim.setIntegerSignal(modelName4 .."call_4",0)\n    end\nend\n\nfunction signal_5(enable)\n    modelBase5=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName5=sim.getObjectName(modelBase5)\n    if enable then\n        sim.setIntegerSignal(modelName5 .."call_5",1)\n    else\n        sim.setIntegerSignal(modelName5 .."call_5",0)\n    end\nend\n\nfunction signal_6(enable)\n\n\n    modelBase6=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName6=sim.getObjectName(modelBase6)\n    if enable then\n        sim.setIntegerSignal(modelName6 .."call_6",1)\n    else\n        sim.setIntegerSignal(modelName6 .."call_6",0)\n    end\nend\n\n\nfunction sysCall_threadmain()\n    on=true\n    joint01=sim.getObjectHandle(\'X\')\n    joint02=sim.getObjectHandle(\'Y\')\n    joint03=sim.getObjectHandle(\'Z\')\n    jointr=sim.getObjectHandle(\'Rotate\')\n    secc=sim.getScriptHandle(\'suctionPad\')\n    dx=0\n    dy=0\n    dz=0\n    dr=0\n    dt=0.01\n    tt=1\n    long_t=1.5\n    long_long_t=3\n    aty=0\n    setx=0.5\n    setpx=-0.5\n    sety=-0.16\n    setpy=-0.16\n    pick_h1=0.0645\n    pick_h2=0.134\n    pick_h3=0.2025\n    pick_h4=0.2768\n    fall_h4=0.26\n    fall_h3=0.18\n    fall_h2=0.12\n    fall_h1=0.05\n    fall_h4_up=0.12\n    fall_h3_up=0.05\n    while (on==true) do\n    signal_1(true)\n    sim.setJointTargetPosition(joint01,setx) --pick_1\n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_2 h2-h2-\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    sim.wait(tt)\n    signal_2(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_3\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    sim.wait(tt)\n    signal_3(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_4\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    sim.wait(tt)\n    signal_4(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_5\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    sim.wait(tt)\n    signal_5(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_6 h3-h3\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    sim.wait(tt)\n    signal_6(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 1\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 2\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 3\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 4\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 5\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 6\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_7\n    sim.setJointTargetPosition(joint02,sety)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_8\n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_9\n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_10\n    sim.setJointTargetPosition(joint02,sety)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_11\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_12\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 7\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 8\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-0.12)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 9\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 10\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 11\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 12\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_13\n    sim.setJointTargetPosition(joint02,sety)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_14 \n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_15 --h4-h4\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_16\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_17\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_18\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 13\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 14\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 15\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 16\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 17 h3--h3\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 18\n    sim.setJointTargetPosition(joint02,setpy-0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_19\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_20 \n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_21\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_22\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_23\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_24\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 19\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 20\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 21\n    sim.setJointTargetPosition(joint02,setpy)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 22\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 23\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 24\n    sim.setJointTargetPosition(joint02,setpy-0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_25\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_26 \n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_27\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_28\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_29\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_30\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 25\n    sim.wait(long_long_t)\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 26\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 27\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 28\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 29\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 30\n    sim.setJointTargetPosition(joint02,setpy)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h1)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    ----------------------------------------------\n    sim.setJointTargetPosition(joint01,0) \n    sim.setJointTargetPosition(joint02,0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    -----------------------------------------------------------\n    -----------------------------------------------------------\n    pick_h1=0.07\n    pick_h2=0.138\n    pick_h3=0.2085\n    pick_h4=0.28\n    setx=-0.51\n    setpx=0.49\n    signal_1(true)\n    sim.setJointTargetPosition(joint01,setx) --pick_1\n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_2 h2-h2-\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    sim.wait(tt)\n    signal_2(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_3\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    sim.wait(tt)\n    signal_3(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_4\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    sim.wait(tt)\n    signal_4(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_5\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    sim.wait(tt)\n    signal_5(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_6 h3-h3\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    sim.wait(tt)\n    signal_6(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 1\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 2\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 3\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 4\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 5\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 6\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_7\n    sim.setJointTargetPosition(joint02,sety)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_8\n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_9\n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_10\n    sim.setJointTargetPosition(joint02,sety)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_11\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_12\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 7\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 8\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-0.12)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 9\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 10\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 11\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 12\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_13\n    sim.setJointTargetPosition(joint02,sety)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_14 \n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_15 --h4-h4\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_16\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_17\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_18\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_long_t)\n    \n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 13\n    sim.wait(long_long_t)\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(long_long_t)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 14\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 15\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 16\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 17 h3--h3\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 18\n    sim.setJointTargetPosition(joint02,setpy-0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_19\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_20 \n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_21\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_22\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_23\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_24\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 19\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 20\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 21\n    sim.setJointTargetPosition(joint02,setpy)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 22\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 23\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 24\n    sim.setJointTargetPosition(joint02,setpy-0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_25\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_26 \n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_27\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_28\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_29\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_30\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 25\n    sim.wait(long_long_t)\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 26\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 27\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 28\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 29\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 30\n    sim.setJointTargetPosition(joint02,setpy)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h1)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    ----------------------------------------------\n    sim.setJointTargetPosition(joint01,0) \n    sim.setJointTargetPosition(joint02,0)\n    setx=0.5\n    setpx=0.5\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    -----------------------------------------------------------\n    end\nend\n\nfunction sysCall_cleanup()\n    -- Put some clean-up code here\nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n \n 吸盤程式 \n function sysCall_init() \n    modelBase1=sim.getObjectAssociatedWithScript(sim.handle_self)\n    robotBase1=modelBase1\n    while true do\n        robotBase1=sim.getObjectParent(robotBase1)\n        if robotBase1==-1 then\n            robotName1=\'Base\'\n            break\n        end\n        robotName1=sim.getObjectName(robotBase1)\n        suffix,suffixlessName=sim.getNameSuffix(robotName1)\n        if suffixlessName==\'Base\' then\n            break\n        end\n    end\n    sa=sim.getObjectHandle(\'suctionPadSensor\')\n    la=sim.getObjectHandle(\'suctionPadLoopClosureDummy1\')\n    l2a=sim.getObjectHandle(\'suctionPadLoopClosureDummy2\')\n    ba=sim.getObjectHandle(\'suctionPad\')\n    suctionPadLink=sim.getObjectHandle(\'suctionPadLink\')\n    local gripperBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n\n    infiniteStrength=sim.getScriptSimulationParameter(sim.handle_self,\'infiniteStrength\')\n    maxPullForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxPullForce\')\n    maxShearForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxShearForce\')\n    maxPeelTorque=sim.getScriptSimulationParameter(sim.handle_self,\'maxPeelTorque\')\n\n    sim.setLinkDummy(la,-1)\n    sim.setObjectParent(la,ba,true)\n    ma=sim.getObjectMatrix(l2a,-1)\n    sim.setObjectMatrix(la,-1,ma)\nend\n\n\nfunction sysCall_cleanup() \n    sim.setLinkDummy(la,-1)\n    sim.setObjectParent(la,ba,true)\n    ma=sim.getObjectMatrix(l2a,-1)\n    sim.setObjectMatrix(la,-1,ma)\nend \n\nfunction sysCall_sensing() \n    parent=sim.getObjectParent(la)\n    local sig=sim.getIntegerSignal(robotName1 .."call_1")\n    if (not sig) or (sig==0) then\n        if (parent~=ba) then\n            sim.setLinkDummy(la,-1)\n            sim.setObjectParent(la,ba,true)\n            ma=sim.getObjectMatrix(l2a,-1)\n            sim.setObjectMatrix(la,-1,ma)\n        end\n    else\n        if (parent==ba) then\n            -- Here we want to detect a respondable shape, and then connect to it with a force sensor (via a loop closure dummy dummy link)\n            -- However most respondable shapes are set to "non-detectable", so "sim.readProximitySensor" or similar will not work.\n            -- But "sim.checkProximitySensor" or similar will work (they don\'t check the "detectable" flags), but we have to go through all shape objects!\n            index=0\n            while true do\n                shape=sim.getObjects(index,sim.object_shape_type)\n                if (shape==-1) then\n                    break\n                end\n                if (shape~=ba) and (sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable)~=0) and (sim.checkProximitySensor(sa,shape)==1) then\n                    -- Ok, we found a respondable shape that was detected\n                    -- We connect to that shape:\n                    -- Make sure the two dummies are initially coincident:\n                    sim.setObjectParent(la,ba,true)\n                    ma=sim.getObjectMatrix(l2a,-1)\n                    sim.setObjectMatrix(la,-1,ma)\n                    -- Do the connection:\n                    sim.setObjectParent(la,shape,true)\n                    sim.setLinkDummy(la,l2a)\n                    break\n                end\n                index=index+1\n            end\n        else\n            -- Here we have an object attached\n            if (infiniteStrength==false) then\n                -- We might have to conditionally beak it apart!\n                result,force,torque=sim.readForceSensor(suctionPadLink) -- Here we read the median value out of 5 values (check the force sensor prop. dialog)\n                if (result>0) then\n                    breakIt=false\n                    if (force[3]>maxPullForce) then breakIt=true end\n                    sf=math.sqrt(force[1]*force[1]+force[2]*force[2])\n                    if (sf>maxShearForce) then breakIt=true end\n                    if (torque[1]>maxPeelTorque) then breakIt=true end\n                    if (torque[2]>maxPeelTorque) then breakIt=true end\n                    if (breakIt) then\n                        -- We break the link:\n                        sim.setLinkDummy(la,-1)\n                        sim.setObjectParent(la,ba,true)\n                        ma=sim.getObjectMatrix(l2a,-1)\n                        sim.setObjectMatrix(la,-1,ma)\n                    end\n                    \n                end\n            end\n        end\n    end\nend \n \n \n', 'tags': '', 'url': '舊版本.html'}, {'title': '尋找控制代碼', 'text': "coppeliasim中 \n simGetSimulatorMessage()為讀取鍵盤狀態的指令 \n 但是我們不知道指令是甚麼，所以寫了一段程式來檢測看每一個按鍵的指令是什麼 \n 所以寫了這一支程式來檢測每一個按鈕的值 \n 在coppeliaSim中叫出一個物件，然後對那個物件編寫程式如下 \n 開始模擬後按下鍵盤鍵即可在下方視窗顯示對應的按鍵 \n \n 程式碼如下 \n function sysCall_actuation()\n    message,auxiliaryData=simGetSimulatorMessage()\n\twhile message~=-1 do\n\t\tif (message==sim_message_keypress) then\n\t\t\tprint(auxiliaryData[1])\n\t\t\tif (auxiliaryData[1]==string.byte(' ')) then\n\t\t\t\t-- space key was pressed\n\t\t\tend\n\t\tend\n\t\tmessage,auxiliaryData=simGetSimulatorMessage()\n\tend\nend \n \n", 'tags': '', 'url': '尋找控制代碼.html'}, {'title': '控制解說', 'text': '5/11 \n 方向鍵上,下，控制大臂的上下移動 \n 方向鍵左,右，控制底座的旋轉 \n 小鍵盤2,8 控制小臂上下移動 \n 小鍵盤4,6 控制小臂的旋轉 \n 小鍵盤1,3 控制手腕的轉動 \n 小鍵盤0 控制小臂是否與大臂連動 \n \n \n', 'tags': '', 'url': '控制解說.html'}, {'title': '0513 機械手臂新增夾爪控制', 'text': '\n 新增一夾爪與兩個攝影機 \n 夾爪可以夾取物品，攝影機可以方便對正要夾取的物品 \n 圖檔: \n Camera contral.ttt \n 參考影片 \n \n \n', 'tags': '', 'url': '0513 機械手臂新增夾爪控制.html'}, {'title': '0511 Programming in C++', 'text': '圖檔: \n programmingl in C++ Unclear.ttt \n 簡介: \n 目前還尚未寫出(5/11)，在編譯上還有問題，問題跟"remoteAPI in C++"中的問題一樣 \n 並且尚未能找到能改語言的方法 \n \n \n \n', 'tags': '', 'url': '0511 Programming in C++.html'}, {'title': '參考資料', 'text': 'coppeliasim 說明書 \n https://www.coppeliarobotics.com/helpFiles/index.html \n coppeliasim 官方教學 \n https://www.coppeliarobotics.com/helpFiles/index.html \n coppeliasim tutorial on youtube(播放清單 \n https://www.youtube.com/watch?v=WJrqt27cYrU&list=PLjzuoBhdtaXOoqkJUqhYQletLLnJP8vjZ&index=3 \n Lua 程式指令 \n https://www.coppeliarobotics.com/helpFiles/index.html \n coppeliasim suctionPad \n https://www.youtube.com/watch?v=vRi2Up0yfyk&t=1927s \n Python remoteApi: \n https://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm \n C++ remoteApi 系統設定: \n https://blog.csdn.net/weixin_44745263/article/details/104555135 \n github 範例: \n https://github.com/orivaldosantana/GPRo \n coppeliasim 相關論壇 (參考內容太多，故僅列論壇首頁 \n https://forum.coppeliarobotics.com/index.php \n coppeliasim 教學部落格 \n https://www.jianshu.com/u/1e3e366da998 \n \n \n', 'tags': '', 'url': '參考資料.html'}, {'title': '舊資料', 'text': '', 'tags': '', 'url': '舊資料.html'}, {'title': '0511 Programming in Lua on multiple program', 'text': '圖檔下載 \n programming in Lua in multiple program.ttt \n 簡介: \n 最基本的控制 \n 在單一軸上對單一軸做程式控制 \n 優點: 程式簡單，變數少 \n 缺點: 要修改程式不易，有幾個程式就需要修改幾次 \n \n \n \n \n \n', 'tags': '', 'url': '0511 Programming in Lua on multiple program.html'}, {'title': '0511 Programming in Lua in One program', 'text': '圖檔 \n programming in Lua in One program.ttt \n 簡介 \n 使用單一程式進行控制 \n 優點: 程式只有一個，所以可以在編寫上比較輕鬆 \n 缺點: 程式較長，尋找特定函式較不易，變數較多程式控制還多，命名上須留意 \n \n \n \n', 'tags': '', 'url': '0511 Programming in Lua in One program.html'}, {'title': 'task2-remoteAPI', 'text': '請各組員分別將個人在 stage1 與 stage2 所完成的 coppeliasim 場景, 採 Python remote API 進行操控, 並將過程拍成影片後, 放在個人與分組網站上. \n stage3 專案中的 CoppeliaSim 請一律使用  4.2.0 版 . \n 範例:  http://mde.tw/cad2020/content/CoppeliaSim.html \n W10 範例: \n 各班上課時所分配到的內部 IP, 192.168.192.1+組別+排序別 \n 意即, 第五組排序別第一即為該組組長, 其 IP 為 192.168.192.151 \n 以  http://mde.tw/cad2020/downloads/coppeliasim/vrep_remoteapi_ex.7z  為例, 每一個 Python3 remote api 程式執行需要  sim.py ,  simConst.py  與  remoteApi.dll  等三個檔案, 若針對 2w1a.ttt 場景, 以下列 Python 程式對位於 192.168.192.1 伺服器上的 CoppeliaSim 場景進行操控: \n import sim as vrep\nimport math\nimport random\nimport time\n\nprint (\'Start\')\n\n# Close eventual old connections\nvrep.simxFinish(-1)\n# Connect to V-REP remote server\nclientID = vrep.simxStart(\'192.168.192.1\', 19997, True, True, 5000, 5)\n\nif clientID != -1:\n    print (\'Connected to remote API server\')\n\n    res = vrep.simxAddStatusbarMessage(\n        clientID, "teacher",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n    # Communication operating mode with the remote API : wait for its answer before continuing (blocking mode)\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiConstants.htm\n    opmode = vrep.simx_opmode_oneshot_wait\n\n    # Try to retrieve motors and robot handlers\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectHandle\n    ret1, wristHandle = vrep.simxGetObjectHandle(clientID, "WristMotor", opmode)\n    ret2, elbowHandle = vrep.simxGetObjectHandle(clientID, "ElbowMotor", opmode)\n    ret3, shoulderHandle = vrep.simxGetObjectHandle(clientID, "ShoulderMotor", opmode)\n    ret4, robotHandle = vrep.simxGetObjectHandle(clientID, "2W1A", opmode)\n\n    # If handlers are OK, execute three random simulations\n    if ret1 == 0 and ret2 == 0 and ret3 == 0:\n        random.seed()\n        for i in range(0, 3):\n            # Start the simulation\n            # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxStartSimulation\n            vrep.simxStartSimulation(clientID, opmode)\n            print("----- Simulation started -----")\n\n            # Start getting the robot position\n            # Unlike other commands, we will use a streaming operating mode\n            # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectPosition\n            pret, robotPos = vrep.simxGetObjectPosition(clientID, robotHandle, -1, vrep.simx_opmode_streaming)\n            print("2w1a position: (x = " + str(robotPos[0]) +\\\n                  ", y = " + str(robotPos[1]) + ")")\n\n            # Start getting the robot orientation\n            # Unlike other commands, we will use a streaming operating mode\n            # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectOrientation\n            oret, robotOrient = vrep.simxGetObjectOrientation(clientID, robotHandle, -1, vrep.simx_opmode_streaming)\n            print("2w1a orientation: (x = " + str(robotOrient[0]) + \\\n                  ", y = " + str(robotOrient[1]) +\\\n                  ", z = " + str(robotOrient[2]) + ")")\n\n            # Make the robot move randomly five times\n            for j in range(0, 5):\n                # Generating random positions for the motors\n                awrist = random.randint(0, 300)\n                aelbow = random.randint(0, 300)\n                ashoulder = random.randint(0, 300)\n\n                # The control functions use Radians to determine the target position.\n                # Here, we use maths.radians to convert degrees into radians.\n                # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxSetJointTargetPosition\n                print("Motors target positions: " + str(ashoulder) + " " + str(aelbow) + " " + str(awrist))\n                vrep.simxSetJointTargetPosition(clientID, wristHandle, math.radians(awrist), opmode)\n                vrep.simxSetJointTargetPosition(clientID, elbowHandle, math.radians(aelbow), opmode)\n                vrep.simxSetJointTargetPosition(clientID, shoulderHandle, math.radians(ashoulder), opmode)\n\n                # Wait in order to let the motors finish their movements\n                # Tip: there must be a more efficient way to do it...\n                time.sleep(5)\n\n                # Get the motors effective positions after the movement sequence\n                # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetJointPosition\n                pwrist = vrep.simxGetJointPosition(clientID, wristHandle, opmode)\n                pelbow = vrep.simxGetJointPosition(clientID, elbowHandle, opmode)\n                pshoulder = vrep.simxGetJointPosition(clientID, shoulderHandle, opmode)\n                print("Motors reached positions: " + str(ashoulder) + " " + str(aelbow) + " " + str(awrist))\n\n                # Get the robot position after the movement sequence\n                pret, robotPos = vrep.simxGetObjectPosition(clientID, robotHandle, -1, vrep.simx_opmode_buffer)\n                print("2w1a position: (x = " + str(robotPos[0]) +\\\n                      ", y = " + str(robotPos[1]) + ")")\n\n                # Get the robot orientation after the movement sequence\n                oret, robotOrient = vrep.simxGetObjectOrientation(clientID, robotHandle, -1, vrep.simx_opmode_buffer)\n                print("2w1a orientation: (x = " + str(robotOrient[0]) +\\\n                      ", y = " + str(robotOrient[1]) +\\\n                      ", z = " + str(robotOrient[2]) + ")")\n\n            # End the simulation, wait to be sure V-REP had the time to stop it entirely\n            # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxStopSimulation\n            vrep.simxStopSimulation(clientID, opmode)\n            time.sleep(1)\n            print("----- Simulation ended -----")\n\n    # Close the connection to V-REP remote server\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxFinish\n    vrep.simxFinish(clientID)\nelse:\n    print (\'Failed connecting to remote API server\')\nprint (\'End\')\n \n CoppeliaSim 場景 remote API 協同監控流程: \n \n 各組員下載  https://portableapps.com/apps/music_video/obs-studio-portable \n 擔任 CoppliaSim 場景直播者時, 必須以 @gm 帳號登入 Youtube 後, 啟動 Live stream 取得直播串流金鑰, 將金鑰輸入 OBS 後, 擷取電腦顯示器啟動串流, 然後利用 copy video url 取得直播網址. \n 將直播網誌公布在  https://gitter.im/mdecourse/cd2021 , 並附上伺服器 IPv4 內部網路 IP 位址與場景開放埠號. \n 直播者同時必須在個人網站上公布 Python remote API 操控直播場景相關參變數以及監控條件. \n 待遠端各協同操控學員準備就緒後, 完成操控流程後將所錄製的影片嵌入個人與分組網站中. \n \n 直播範例錄影: \n \n 參考資料: \n RoboComp is a cutting-edge open-source robotics framework providing tools to easily create, modify and manage robot software components. \n https://github.com/mdecourse/robocomp \n Code to connect RocoComp to V-REP \n https://github.com/mdecourse/V-REP-component \n', 'tags': '', 'url': 'task2-remoteAPI.html'}, {'title': '機械手臂多人對戰', 'text': '圖檔下載 \n robot arm fight \n 場景設定: \n 需到根目錄之 remoteApiConnections.txt在最下方新增以下文字 \n portIndex2_port             = 19998\nportIndex2_debug            = false\nportIndex2_syncSimTrigger   = true \n 然後需要打開cmd 輸入ipconfig 查看ipv4位置 \n 再打開兩個主控程式將ipv4位置填入 \n 示範影片 \n \n \n 構想來源 \n \n \n', 'tags': '', 'url': '機械手臂多人對戰.html'}, {'title': '自動吹笛子機', 'text': 'Stage1-bg6 自動吹笛子機remoteApi \n 控制: \n f,d,s,j,k,l 分別控制六根不同的桿子往下 \n r,e,w,u,i,o 控制六根桿子往上 \n \n 下載 \n 吹笛子程式.rar \n 自動吹笛子remoteApi.ttt \n 參考影片 \n \n 程式參考 \n import sim as vrep\nimport math\nimport random\nimport time\nimport keyboard\nimport math\n#from winsound import Beep\n\n \nprint (\'Start\')\n \n\nvrep.simxFinish(-1)\n\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n \nif clientID != -1:\n    print (\'Connected to remote API server\')\n     \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "test-25",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n \n    \n    opmode = vrep.simx_opmode_oneshot_wait\n    STREAMING = vrep.simx_opmode_streaming\n \n    \n    vrep.simxStartSimulation(clientID, opmode)\n    ret,joint1=vrep.simxGetObjectHandle(clientID,"Revolute3_1",opmode)\n    ret,joint2=vrep.simxGetObjectHandle(clientID,"Revolute3_2",opmode)\n    ret,joint3=vrep.simxGetObjectHandle(clientID,"Revolute3_3",opmode)\n    ret,joint4=vrep.simxGetObjectHandle(clientID,"Revolute3_4",opmode)\n    ret,joint5=vrep.simxGetObjectHandle(clientID,"Revolute3_5",opmode)\n    ret,joint6=vrep.simxGetObjectHandle(clientID,"Revolute3_6",opmode)\n\n    ret,joint01=vrep.simxGetObjectHandle(clientID,"joint0_1",opmode)\n    ret,joint02=vrep.simxGetObjectHandle(clientID,"joint0_2",opmode)\n    ret,joint03=vrep.simxGetObjectHandle(clientID,"joint0_3",opmode)\n    ret,joint04=vrep.simxGetObjectHandle(clientID,"joint0_4",opmode)\n    ret,joint05=vrep.simxGetObjectHandle(clientID,"joint0_5",opmode)\n    ret,joint06=vrep.simxGetObjectHandle(clientID,"joint0_6",opmode)\n\n    degr=-12*math.pi/180\n    py=0.05\n    set1=False\n    set2=False\n    set3=False\n    set4=False\n    set5=False\n    set6=False\n\n    vrep.simxSetJointTargetPosition(clientID,joint1,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint2,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint3,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint4,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint04,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint5,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint05,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint6,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint06,0,opmode)\n\n    while True:\n        \n        if keyboard.is_pressed("f"):\n            if set1==False:\n                vrep.simxSetJointTargetPosition(clientID,joint1,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint01,py,opmode)\n                set1=True\n        if keyboard.is_pressed("d"):\n            if set2==False:\n                vrep.simxSetJointTargetPosition(clientID,joint2,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint02,py,opmode)\n                set2=True\n        if keyboard.is_pressed("s"):\n            if set3==False:\n                vrep.simxSetJointTargetPosition(clientID,joint3,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint03,py,opmode)\n                set3=True\n        if keyboard.is_pressed("j"):\n            if set4==False:\n                vrep.simxSetJointTargetPosition(clientID,joint4,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint04,py,opmode)\n                set4=True\n        if keyboard.is_pressed("k"):\n            if set5==False:\n                vrep.simxSetJointTargetPosition(clientID,joint5,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint05,py,opmode)\n                set5=True\n        if keyboard.is_pressed("l"):\n            if set6==False:\n                vrep.simxSetJointTargetPosition(clientID,joint6,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint06,py,opmode)\n                set6=True\n\n        \n        if keyboard.is_pressed("r"):\n            if set1==True:\n                vrep.simxSetJointTargetPosition(clientID,joint1,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n                set1=False\n        if keyboard.is_pressed("e"):\n            if set2==True:\n                vrep.simxSetJointTargetPosition(clientID,joint2,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n                set2=False\n        if keyboard.is_pressed("w"):\n            if set3==True:\n                vrep.simxSetJointTargetPosition(clientID,joint3,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n                set3=False\n        if keyboard.is_pressed("u"):\n            if set4==True:\n                vrep.simxSetJointTargetPosition(clientID,joint4,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint04,0,opmode)\n                set4=False\n        if keyboard.is_pressed("i"):\n            if set5==True:\n                vrep.simxSetJointTargetPosition(clientID,joint5,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint05,0,opmode)\n                set5=False\n        if keyboard.is_pressed("o"):\n            if set6==True:\n                vrep.simxSetJointTargetPosition(clientID,joint6,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint06,0,opmode)\n                set6=False\n        \n        #if(set1==true ):\n            #Beep(422, 3000) \n        \n \n \nelse:\n    print (\'Failed connecting to remote API server\')\n    print (\'End\') \n \n \n', 'tags': '', 'url': '自動吹笛子機.html'}, {'title': '3D列印機', 'text': '使用python remoteApi進行遠端控制 \n 控制: \n 上下左右控制噴頭的上下左右 \n 空白鍵往上 \n C鍵往下 \n 圖檔 \n 3D print remoteApi program \n 3D print remoteApi.ttt \n \n 程式參考 \n 5/18 程式修改:將顯示的數值由公尺轉成毫米並且去掉多餘的小數點 \n import sim as vrep\nimport math\nimport random\nimport time\nimport keyboard\n \nprint (\'Start\')\n \n# Close eventual old connections\nvrep.simxFinish(-1)\n\n# Connect to V-REP remote server\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n \nif clientID != -1:\n    print (\'Conipconfigected to remote API server\')\n    \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "40823214",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n \n\n    opmode = vrep.simx_opmode_oneshot_wait\n    STREAMING = vrep.simx_opmode_streaming\n\n    vrep.simxStartSimulation(clientID, opmode)\n\n    ret,joint1=vrep.simxGetObjectHandle(clientID,"X",opmode)\n    ret,joint2=vrep.simxGetObjectHandle(clientID,"Y",opmode)\n    ret,joint3=vrep.simxGetObjectHandle(clientID,"Z",opmode)\n    dx=0\n    dy=0\n    dz=0\n    dt=0.005\n    cont=0\n    rangeR=0.013\n    max_h=0.35\n    vrep.simxSetJointTargetPosition(clientID,joint1,dx,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint2,dx,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint3,dx,opmode)\n\n    while True:\n        #Clockwise\n        if keyboard.is_pressed("8"):\n            dx=dx+dt\n            cont=float(math.pow(dx,2)+math.pow(dy,2))\n            if cont<rangeR:\n                vrep.simxSetJointTargetPosition(clientID,joint1,dx,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("Out of range")\n                dx=dx-dt\n        if keyboard.is_pressed("2"):\n            dx=dx-dt\n            cont=float(math.pow(dx,2)+math.pow(dy,2))\n            if cont<rangeR:\n                vrep.simxSetJointTargetPosition(clientID,joint1,dx,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("Out of range")\n                dx=dx+dt\n        if keyboard.is_pressed("4"):\n            dy=dy+dt\n            cont=float(math.pow(dx,2)+math.pow(dy,2))\n            if cont<rangeR:\n                vrep.simxSetJointTargetPosition(clientID,joint2,dy,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("Out of range")\n                dy=dy-dt\n        if keyboard.is_pressed("6"):\n            dy=dy-dt\n            cont=float(math.pow(dx,2)+math.pow(dy,2))\n            if cont<rangeR:\n                vrep.simxSetJointTargetPosition(clientID,joint2,dy,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("Out of range")\n                dy=dy+dt\n        if keyboard.is_pressed("space"):    \n            dz=dz+dt   \n            if dz<max_h:       \n                vrep.simxSetJointTargetPosition(clientID,joint3,dz,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("too high")\n                dz=dz-dt \n        if keyboard.is_pressed("c"):\n            dz=dz-dt\n            if dz<0:\n                print("too low")\n                dz=0\n            else:\n                vrep.simxSetJointTargetPosition(clientID,joint3,dz,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n    else:\n        print (\'Failed connecting to remote API server\')\n        print (\'End\') \n \n', 'tags': '', 'url': '3D列印機.html'}, {'title': 'W13 Pick and Place remoteApi', 'text': '', 'tags': '', 'url': 'W13 Pick and Place remoteApi.html'}, {'title': '0601', 'text': '圖檔參考 \n Pick and Place \n 角度控制解說 \n https://40823225.github.io/stage3-bg6/content/%E8%A8%88%E7%AE%97%E8%A7%92%E5%BA%A6.html \n 影片參考 \n \n 程式參考(python remoteApi) \n import sim as vrep\nimport math\nimport random\nimport time\nimport math\n\ndef rotate_motor(x,y,z,switch):\n    x=float(x)\n    y=float(y)\n    z=float(z)\n    deg1=math.atan(x/(1.415-y))\n    x=1.415-(1.415-y)/math.cos(deg1)\n    length=math.pow((math.pow(0.2,2)+math.pow(1.082,2)),0.5)\n    distance=math.pow((math.pow(1.082-x,2)+math.pow(0.96-z,2)),0.5)\n    perimeter=(length+distance+0.76)/2\n    area=math.pow(perimeter*(perimeter-length)*(perimeter-distance)*(perimeter-0.76),0.5)\n    high=2*area/distance\n    joint2_after_sita=math.asin(high/0.76)\n    joint2_zero_sita=math.atan((1.082-x)/(0.96-z))\n    deg2=joint2_after_sita-joint2_zero_sita\n    joint3_base=math.atan(1.082/0.2)\n    angle_joint3=math.acos(high/length)\n    deg3=(90*math.pi/180)+joint2_after_sita-angle_joint3-joint3_base\n    deg4=deg2-deg3\n    if switch==1:\n        vrep.simxSetJointTargetPosition(clientID,joint01,deg1,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint02,deg2,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint03,(-deg3),opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint04,(-deg4),opmode)\n    if switch==2:\n        vrep.simxSetJointTargetPosition(clientID,joint03,(-deg3),opmode)\n        time.sleep(0.2)\n        vrep.simxSetJointTargetPosition(clientID,joint01,deg1,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint02,deg2,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint04,(-deg4),opmode)\n\ndef signal_switch(singal):\n\n    if singal==1 :\n        vrep.simxSetIntegerSignal(clientID,"call_1",1,opmode) #here might have a error\n    if singal==2 :\n        vrep.simxSetIntegerSignal(clientID,"call_2",1,opmode)\n    if singal==3 :\n        vrep.simxSetIntegerSignal(clientID,"call_3",1,opmode)\n    if singal==4 :\n        vrep.simxSetIntegerSignal(clientID,"call_4",1,opmode)\n    if singal==5 :\n        vrep.simxSetIntegerSignal(clientID,"call_5",1,opmode)\n    if singal==6 :\n        vrep.simxSetIntegerSignal(clientID,"call_6",1,opmode)\n    if singal==12:\n        vrep.simxSetIntegerSignal(clientID,\'call_1\',0,opmode) #here might have a error\n    if singal==11:\n        vrep.simxSetIntegerSignal(clientID,"call_2",0,opmode)\n    if singal==10:\n        vrep.simxSetIntegerSignal(clientID,"call_3",0,opmode)\n    if singal==9:\n        vrep.simxSetIntegerSignal(clientID,"call_4",0,opmode)\n    if singal==8:\n        vrep.simxSetIntegerSignal(clientID,"call_5",0,opmode)\n    if singal==7:\n        vrep.simxSetIntegerSignal(clientID,"call_6",0,opmode)\n\ndef clean():\n    vrep.simxSetIntegerSignal(clientID,"call_1",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_2",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_3",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_4",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_5",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_6",0,opmode)\n\nprint (\'Start\')\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n  \nif clientID != -1:\n    print (\'Connected to remote API server\')\n      \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "pad testing",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n  \n     \n    opmode = vrep.simx_opmode_oneshot_wait\n    STREAMING = vrep.simx_opmode_streaming\n  \n     \n    vrep.simxStartSimulation(clientID, opmode)\n    ret,joint01=vrep.simxGetObjectHandle(clientID,"joint1",opmode)\n    ret,joint02=vrep.simxGetObjectHandle(clientID,"joint2",opmode)\n    ret,joint03=vrep.simxGetObjectHandle(clientID,"joint3",opmode)\n    ret,joint04=vrep.simxGetObjectHandle(clientID,"joint4",opmode)\n    ret,jointr=vrep.simxGetObjectHandle(clientID,"Rotate",opmode)\n    tt=1.5\n    long_t=3\n    long_long_t=3 #time set\n    rotate_deg=0 #pad rotate\n    atz=0  #altitude set\n    setx=-0.5\n    setpx=0.5 #center pick set\n    sety=0.16\n    setpy=0.16 #center fall set\n    cube=1              # set cube\n    ball_pick_time=0    #total ball we pick\n    ball_put_time=31     #total ball we put\n    put_cont=0          # print the ball we put\n    pick_high=[\'0.0645\',\'0.134\',\'0.202\',\'0.2785\'] #pick up high set\n    fall_high=[\'0.05\',\'0.12\',\'0.18\',\'0.26\'] #fall high set\n    high_up=[\'0\',\'0\',\'0.05\',\'0.12\']\n\n    \n    \n\n    while True :\n        clean() #clean all the \n        vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint04,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,jointr,0,opmode)\n        time.sleep(tt)\n        for ball in range(1,7,1):\n            ball_pick_time=ball_pick_time+1 #total time we pick\n            i=1\n            unit=0\n            level=0\n            while level < ball_pick_time :  #find which level and place should be of the xy coordinates\n                unit=unit+1\n                level=level+unit**2\n            finding_XY=ball_pick_time  #this is the XY on that floor\n            while i<=unit-1:\n                finding_XY=finding_XY-(i**2) \n                i=i+1\n            X_Pos=finding_XY%unit  #the X and Y coordinates(by balls)\n            if X_Pos==0:\n                X_Pos=unit\n            Y_Pos=(math.ceil(finding_XY/unit)) \n            BaseX=setx-((unit-1)*0.05)#now we need to find the 0 of the xy\n            BaseY=sety-((unit-1)*0.05)\n            #vrep.simxSetJointTargetPosition(clientID,joint01,BaseX+(0.1*(X_Pos-1)),opmode)\n            #time.sleep(tt)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),high_up[(unit-1)],1)\n            time.sleep(tt)\n            print("Picking up the ball nember",ball_pick_time,"...")\n            signal_switch(ball)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),pick_high[(unit-1)],1)\n            time.sleep(tt)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),high_up[(unit-1)],2)\n            time.sleep(tt)\n            rotate_deg=rotate_deg+60\n            vrep.simxSetJointTargetPosition(clientID,jointr,rotate_deg*math.pi/180,opmode)\n            time.sleep(tt)\n        vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint04,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,jointr,0,opmode)\n        time.sleep(tt)\n        for ball in range(1,7,1):\n            ball_put_time=ball_put_time-1 #total time we put\n            put_cont=put_cont+1\n            i=1\n            unit=0\n            level=0\n            while level < ball_put_time :\n                unit=unit+1\n                level=level+unit**2\n            finding_XY=ball_put_time \n            while i<=unit-1:\n                finding_XY=finding_XY-(i**2) \n                i=i+1\n            X_Pos=finding_XY%unit\n            if X_Pos==0:\n                X_Pos=unit\n            Y_Pos=(math.ceil(finding_XY/unit)) \n            BaseX=setpx-((unit-1)*0.05)#now we need to find the 0 of the xy\n            BaseY=setpy-((unit-1)*0.05)\n            rotate_deg=rotate_deg-60\n            vrep.simxSetJointTargetPosition(clientID,jointr,rotate_deg*math.pi/180,opmode)\n            time.sleep(tt)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),high_up[(unit-1)],1)\n            time.sleep(tt)\n            print("Putting the ball nember",put_cont,"...")\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),fall_high[(unit-1)],1)\n            time.sleep(tt)\n            signal_switch((ball+6))\n            time.sleep(0.5)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),high_up[(unit-1)],1)\n            time.sleep(tt)\n        if ball_pick_time==30:\n            pick_high=[\'0.07\',\'0.135\',\'0.207\',\'0.278\']\n            setx=-setx\n            setpx=-setpx\n            ball_pick_time=0\n            ball_put_time=31\n            put_cont=0 \n \n', 'tags': '', 'url': '0601.html'}, {'title': '0524', 'text': '圖檔 \n W13 Pick and Place \n \n', 'tags': '', 'url': '0524.html'}, {'title': 'remoteAPI in C++', 'text': '', 'tags': '', 'url': 'remoteAPI in C++.html'}, {'title': '0511', 'text': '嘗試以C++最為remoteAPI控制的語言 \n compiler為code block in Win10 \n 不論怎麼修改在 \n 後還是出現問題 \n simxGetObjectHandle(clientID, "joint1", &joint01, simx_opmode_oneshot_wait); \n 上程式片段中 \n simx_opmode_oneshot_wait \n 此定義一直出現error，內容如下 \n error: \'simx_opmode_oneshot_wait\' was not declared in this scope \n 中譯:\xa0 simx_opmode_oneshot_wait 定義不明 \n 但是在尋找網路上的範例，寫法也都是如我程式中一樣，目前還在尋找解決方法 \n \n \n 附上程式 \n #include <Windows.h>\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n\nextern "C" {\n    #include "remoteAPI/extApi.h"\n}\n\n\n\nusing namespace std;\n\nint main(){\n    int clientID = 0;\n    simxFinish(-1);\n    clientID = simxStart((simxChar*)"127.0.0.1", 19997, true, true, 5000, 5);\n    Sleep(1);\n    if (clientID != -1)\n    {\n        int joint01;\n        int joint02;\n        int joint03;\n        int joint04;\n        int joint05;\n        simxGetObjectHandle(clientID, "joint1", &joint01, simx_opmode_oneshot_wait);//setting\n        simxGetObjectHandle(clientID, "joint2", &joint02, simx_opmode_oneshot_wait);\n        simxGetObjectHandle(clientID, "joint3", &joint03, simx_opmode_oneshot_wait);\n        simxGetObjectHandle(clientID, "joint4", &joint04, simx_opmode_oneshot_wait);\n        simxGetObjectHandle(clientID, "joint5", &joint05, simx_opmode_oneshot_wait);\n\n\n        float degset01=-11.9;\n        float degset02=34.69;\n        float degset03=-20.2;\n        float degset04=-11.9;\n        float degset05=-11.9;\n        float dif=1;\n\n        //angle set0\n        simxSetJointTargetPosition(clientID,joint01,degset01,simx_opmode_oneshot);\n        simxSetJointTargetPosition(clientID,joint02,degset02,simx_opmode_oneshot);\n        simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n        simxSetJointTargetPosition(clientID,joint04,degset04,simx_opmode_oneshot);\n        simxSetJointTargetPosition(clientID,joint05,degset05,simx_opmode_oneshot);\n        bool balance_contral=true;\n\n\n        clientID,auxiliaryData=simGetSimulatorMessage();\n\n\n        while (clientID!=-1) {\n            if (clientID==simxmessage_keypress) {\n                if (auxiliaryData[1]==2009) { //up Key\n                    degset01=degset01+dif;\n                    simxSetJointTargetPosition(clientID,joint01,degset01,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==2010) { //down key\n                    degset01=degset01-dif;\n                    simxSetJointTargetPosition(clientID,joint01,degset01,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==2007) { //left key\n                    degset02=degset02+dif;\n                    simxSetJointTargetPosition(clientID,joint02,degset02,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==2008) {  //right key\n                    degset02=degset02-dif;\n                    simxSetJointTargetPosition(clientID,joint02,degset02,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==56) { //num8 key\n                    degset03=degset03+dif;\n                    simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==50) { //num2 key\n                    degset03=degset03-dif;\n                    simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n\n                }\n                if (auxiliaryData[1]==54) { //num6 key\n                    degset04=degset04+dif;\n                    simxSetJointTargetPosition(clientID,joint04,degset04,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==52) { //num4 key\n                    degset04=degset04-dif;\n                    simxSetJointTargetPosition(clientID,joint04,degset04,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==49) { //mun1 key\n                    degset05=degset05+dif;\n                    simxSetJointTargetPosition(clientID,joint05,degset05,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==51) { //num3 key\n                    degset05=degset05-dif;\n                    simxSetJointTargetPosition(clientID,joint05,degset05,simx_opmode_oneshot);\n                }\n\n\n\n\n                if  (auxiliaryData[1]==48){ //setting auto Balance at num0 key\n                    if (balance_contral==true){\n                        balance_contral=false;\n                    }else{\n                        balance_contral=true;\n                    }\n                }\n                if (balance_contral==true) {\n                    if (auxiliaryData[1]==2007) {\n                        degset03=degset03+dif ;\n                        simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n                    }\n                    if (auxiliaryData[1]==2008) {\n                        degset03=degset03-dif;\n                        simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n                        }\n                    }\n                }\n        clientID,auxiliaryData=simGetSimulatorMessage();\n        }\n    }\n    simxFinish(clientID);\n    return clientID;\n}\n \n \n', 'tags': '', 'url': '0511.html'}, {'title': '0512', 'text': '後來上網尋找解答發現疑似是complier的問題 \n 於是切換為VS2019進行編譯 \n 並且新增path及include至專案檔 \n 在X64的環境下進行DeBug後 \n 第一個錯誤是這個 \n \n 並且出現以下錯誤 \n \n C4244為警示狀態外，其他錯誤經查詢發現似乎不能啟動"remotaApi.dll"的這個程式 \n \n \n', 'tags': '', 'url': '0512.html'}, {'title': '0512-2', 'text': '後來經過修改與PATH路徑修正 \n 並且將remotaApi所需的標頭檔 \n #include <exApi.h> \n 將其修改程式變成 \n extern "C" {\n   \xa0#include "exApi.h" \n} \n 但是似乎還是一樣 \n \n 目前正在尋找其他解法來修復 \n \n \n', 'tags': '', 'url': '0512-2.html'}, {'title': 'remoteAPI in python', 'text': '', 'tags': '', 'url': 'remoteAPI in python.html'}, {'title': '0513-1', 'text': '嘗試用remoteAPI鍵盤控制機械手臂，不過手臂上段模擬時出現甩動問題，因此只展示下半部分。 \n \n \n 程式碼 \n # File created by Thibaut Royer, Epitech school\n# thibaut1.royer@epitech.eu\n# It intends to be an example program for the "Two wheels, one arm" educative project.\n\nimport sim as vrep\nimport math\nimport random\nimport time\nimport keyboard\n\nprint (\'Start\')\n\n# Close eventual old connections\nvrep.simxFinish(-1)\n# Connect to V-REP remote server\nclientID = vrep.simxStart(\'192.168.0.4\', 19997, True, True, 5000, 5)\n\nif clientID != -1:\n    print (\'Connected to remote API server\')\n    \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "40823218",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n\n    # Communication operating mode with the remote API : wait for its answer before continuing (blocking mode)\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiConstants.htm\n    opmode = vrep.simx_opmode_oneshot_wait\n    STREAMING = vrep.simx_opmode_streaming\n\n    # Try to retrieve motors and robot handlers\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectHandle\n    vrep.simxStartSimulation(clientID, opmode)\n    ret,base_handle=vrep.simxGetObjectHandle(clientID,"joint1_",opmode)\n    ret,bottom_handle=vrep.simxGetObjectHandle(clientID,"joint2_",opmode)\n    ret,top_handle=vrep.simxGetObjectHandle(clientID,"joint3_",opmode)\n    ret,rotate_handle=vrep.simxGetObjectHandle(clientID,"joint4_",opmode)\n    ret,wrist_handle=vrep.simxGetObjectHandle(clientID,"joint5_",opmode)\n    while True:\n        #Clockwise\n        if keyboard.is_pressed("a"):\n         vrep.simxSetJointTargetVelocity(clientID,base_handle,0.1,opmode)\n        #anti-Clockwise \n        if keyboard.is_pressed("f"):\n         vrep.simxSetJointTargetVelocity(clientID,base_handle,-0.1,opmode)\n        #bottom_handle up\n        if keyboard.is_pressed ("w"):\n         vrep.simxSetJointTargetVelocity(clientID,bottom_handle,0.1,opmode)\n        #bottom_handle down\n        if keyboard.is_pressed ("s"):\n         vrep.simxSetJointTargetVelocity(clientID,bottom_handle,-0.1,opmode)\n         #top_handle up\n        if keyboard.is_pressed ("e"):\n         vrep.simxSetJointTargetVelocity(clientID,top_handle,0.1,opmode)\n         #top_handle down\n        if keyboard.is_pressed ("d"):\n         vrep.simxSetJointTargetVelocity(clientID,top_handle,-0.1,opmode)\n         #rotate\n        if keyboard.is_pressed ("r"):\n         vrep.simxSetJointTargetVelocity(clientID,rotate_handle,0.1,opmode)\n         #wrist_handle left\n        if keyboard.is_pressed ("j"):\n         vrep.simxSetJointTargetVelocity(clientID,wrist_handle,0.1,opmode)\n         #wrist_handle right\n        if keyboard.is_pressed ("k"):\n         vrep.simxSetJointTargetVelocity(clientID,wrist_handle,-0.1,opmode)\n         #stop\n        if keyboard.is_pressed ("space"):\n         vrep.simxSetJointTargetVelocity(clientID,base_handle,0,opmode)\n         vrep.simxSetJointTargetVelocity(clientID,bottom_handle,0,opmode)\n         vrep.simxSetJointTargetVelocity(clientID,top_handle,0,opmode)\n         vrep.simxSetJointTargetVelocity(clientID,rotate_handle,0,opmode)\n         vrep.simxSetJointTargetVelocity(clientID,wrist_handle,0,opmode)\n\n\nelse:\n    print (\'Failed connecting to remote API server\')\n    print (\'End\')\n \n \n', 'tags': '', 'url': '0513-1.html'}, {'title': '0517', 'text': '經過修改後成功模擬 \n 操作前必須安裝 python keyboard \n 檔案下載: https://drive.google.com/file/d/1FErGMzyfP5MTvf8cLc1Ox2xHJhuDN1XH/view?usp=sharing \n \n \n # File created by Thibaut Royer, Epitech school\n# thibaut1.royer@epitech.eu\n# It intends to be an example program for the "Two wheels, one arm" educative project.\n \nimport sim as vrep\nimport math\nimport random\nimport time\nimport keyboard\n \nprint (\'Start\')\n \n# Close eventual old connections\nvrep.simxFinish(-1)\n# Connect to V-REP remote server\nclientID = vrep.simxStart(\'192.168.0.4\', 19997, True, True, 5000, 5)\n \nif clientID != -1:\n    print (\'Connected to remote API server\')\n     \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "40823218",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n \n    # Communication operating mode with the remote API : wait for its answer before continuing (blocking mode)\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiConstants.htm\n    opmode = vrep.simx_opmode_oneshot_wait\n    STREAMING = vrep.simx_opmode_streaming\n \n    # Try to retrieve motors and robot handlers\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectHandle\n    vrep.simxStartSimulation(clientID, opmode)\n    ret,base_handle=vrep.simxGetObjectHandle(clientID,"joint1",opmode)\n    ret,bottom_handle=vrep.simxGetObjectHandle(clientID,"joint2",opmode)\n    ret,top_handle=vrep.simxGetObjectHandle(clientID,"joint3",opmode)\n    ret,rotate_handle=vrep.simxGetObjectHandle(clientID,"joint4",opmode)\n    ret,wrist_handle=vrep.simxGetObjectHandle(clientID,"joint5",opmode)\n    while True:\n        #Clockwise\n        if keyboard.is_pressed("a"):\n         vrep.simxSetJointTargetVelocity(clientID,base_handle,0.2,opmode)\n        #anti-Clockwise \n        if keyboard.is_pressed("f"):\n         vrep.simxSetJointTargetVelocity(clientID,base_handle,-0.2,opmode)\n        #bottom_handle up\n        if keyboard.is_pressed ("w"):\n         vrep.simxSetJointTargetVelocity(clientID,bottom_handle,0.2,opmode)\n        #bottom_handle down\n        if keyboard.is_pressed ("s"):\n         vrep.simxSetJointTargetVelocity(clientID,bottom_handle,-0.2,opmode)\n         #top_handle up\n        if keyboard.is_pressed ("e"):\n         vrep.simxSetJointTargetVelocity(clientID,top_handle,0.2,opmode)\n         #top_handle down\n        if keyboard.is_pressed ("d"):\n         vrep.simxSetJointTargetVelocity(clientID,top_handle,-0.2,opmode)\n         #rotate\n        if keyboard.is_pressed ("r"):\n         vrep.simxSetJointTargetVelocity(clientID,rotate_handle,0.2,opmode)\n         #wrist_handle left\n        if keyboard.is_pressed ("j"):\n         vrep.simxSetJointTargetVelocity(clientID,wrist_handle,0.2,opmode)\n         #wrist_handle right\n        if keyboard.is_pressed ("k"):\n         vrep.simxSetJointTargetVelocity(clientID,wrist_handle,-0.2,opmode)\n         #stop\n        if keyboard.is_pressed ("space"):\n         vrep.simxSetJointTargetVelocity(clientID,base_handle,0,opmode)\n         vrep.simxSetJointTargetVelocity(clientID,bottom_handle,0,opmode)\n         vrep.simxSetJointTargetVelocity(clientID,top_handle,0,opmode)\n         vrep.simxSetJointTargetVelocity(clientID,rotate_handle,0,opmode)\n         vrep.simxSetJointTargetVelocity(clientID,wrist_handle,0,opmode)\n \n \nelse:\n    print (\'Failed connecting to remote API server\')\n    print (\'End\') \n \n', 'tags': '', 'url': '0517.html'}, {'title': 'remoteApi in Lua', 'text': '', 'tags': '', 'url': 'remoteApi in Lua.html'}, {'title': '0513-2', 'text': '.. \n', 'tags': '', 'url': '0513-2.html'}, {'title': 'stage3', 'text': '', 'tags': '', 'url': 'stage3.html'}, {'title': 'task', 'text': '', 'tags': '', 'url': 'task.html'}, {'title': 'task1', 'text': 'def stu2b(account):\n return account\nteamb = []\n \nwith open("stage3_2b.txt") as fh:     #讀取stage3_2b的檔案\n    data = fh.readlines()\n    data = [a.replace(\'40823231\',\'40823231-2\') for a in data]      #將40823231換成40823231-2\n    data = [a.replace(\'407\',\'s407\') for a in data]     #將有407的學號換成s407\n\nfor i in range(len(data)):     #數據中會有\\n跟\\t，將\\n跟\\t去除\n    group = data[i].rstrip("\\n").split("\\t")\n    teamb.append(group)\n     \noutput = ""    \nseperator = "-"*10 + "</br>"     #分隔號製作\n \nfor i in teamb[0:]:    #小組 組長 其他六個組員\n    team = i[0]\n    leader = stu2b(i[1])\n    m1 = stu2b(i[3])\n    m2 = stu2b(i[5])\n    m3 = stu2b(i[7])\n    m4 = stu2b(i[9])\n    m5 = stu2b(i[11])\n    m6 = stu2b(i[13])\n\n         \n    leaderrepo = "<a href=\'http://github.com/" + leader + "/cd2021\'>" + leader + " repo</a>"    #組長以及組員的倉儲和網站\n    leadersite = "<a href=\'http://" + leader + ".github.io/cd2021\'>" + leader +  " site</a>"\n    m1repo = "<a href=\'http://github.com/" + m1 + "/cd2021\'>" + m1 + " repo</a>"\n    m1site = "<a href=\'http://" + m1 + ".github.io/cd2021\'>" + m1 +  " site</a>"\n    m2repo = "<a href=\'http://github.com/" + m2 + "/cd2021\'>" + m2 + " repo</a>"\n    m2site = "<a href=\'http://" + m2 + ".github.io/cd2021\'>" + m2 +  " site</a>"\n    m3repo = "<a href=\'http://github.com/" + m3 + "/cd2021\'>" + m3 + " repo</a>"\n    m3site = "<a href=\'http://" + m3 + ".github.io/cd2021\'>" + m3 +  " site</a>"\n    m4repo = "<a href=\'http://github.com/" + m4 + "/cd2021\'>" + m4 + " repo</a>"\n    m4site = "<a href=\'http://" + m4 + ".github.io/cd2021\'>" + m4 +  " site</a>"\n    m5repo = "<a href=\'http://github.com/" + m5 + "/cd2021\'>" + m5 + " repo</a>"\n    m5site = "<a href=\'http://" + m5 + ".github.io/cd2021\'>" + m5 +  " site</a>"\n    m6repo = "<a href=\'http://github.com/" + m6 + "/cd2021\'>" + m6 + " repo</a>"\n    m6site = "<a href=\'http://" + m6 + ".github.io/cd2021\'>" + m6 +  " site</a>"\n  \n \n    teamrepo = "<a href=\'http://github.com/" + leader + "/" + team + "\'>" + team + " repo</a>"     #小組的倉儲含網站\n    teamsite =  "<a href=\'http://" + m1 + ".github.io/" + team + "\'>" + team +  " site</a>"\n \n    output += teamrepo + " | " + teamsite + " | " +leaderrepo + " | " + leadersite + " | " +m1repo + " | " + m1site + " | " +m2repo + " | " + m2site + " | " +m3repo + " | " + m3site + " | " +m4repo + " | " + m4site + " | " +m5repo + " | " + m5site + " | " +m6repo + " | " + m6site \n     \n          \n    try:\n        m7 = stu2b(i[15])     #第七個組員\n    except:\n        m7 = ""\n    try:\n        m8 = stu2b(i[17])     #第八個組員\n    except:\n        m8 = ""\n        \n    if m7 != "":\n       m7repo = "<a href=\'http://github.com/" + m7 + "/cd2021\'>" + m7 + " repo</a>"     #如果有第七個組員會再加倉儲和網站沒有的話就空白\n       m7site = "<a href=\'http://" + m7 + ".github.io/cd2021\'>" + m7 +  " site</a>"   \n       output += " |  " + m7repo + "| " + m7site\n    else:\n        output += "" \n     \n    if m8 != "":\n       m8repo = "<a href=\'http://github.com/" + m8 + "/cd2021\'>" + m8 + " repo</a>"     #如果有第八個組員會再加倉儲和網站最後再加分隔線\n       m8site = "<a href=\'http://" + m8 + ".github.io/cd2021\'>" + m8 +  " site</a>"   \n       output += " |  " + m8repo + "| " + m8site + "<br />" + seperator\n    else:\n        output += "<br />" + seperator\n \n \nprint(output)     #輸出 \n stage3-bg1 repo  |  stage3-bg1 site  |  40823245 repo  |  40823245 site  |  40823251 repo  |  40823251 site  |  40823208 repo  |  40823208 site  |  40823213 repo  |  40823213 site  |  40823232 repo  |  40823232 site  |  40823234 repo  |  40823234 site  |  40823235 repo  |  40823235 site  |  40823246 repo |  40823246 site ---------- stage3-bg2 repo  |  stage3-bg2 site  |  40823217 repo  |  40823217 site  |  40823201 repo  |  40823201 site  |  40823209 repo  |  40823209 site  |  40823210 repo  |  40823210 site  |  40823206 repo  |  40823206 site  |  40823207 repo  |  40823207 site  |  40823223 repo  |  40823223 site  |  40823224 repo |  40823224 site ---------- stage3-bg3 repo  |  stage3-bg3 site  |  40823236 repo  |  40823236 site  |  40823202 repo  |  40823202 site  |  40823203 repo  |  40823203 site  |  40823212 repo  |  40823212 site  |  40823219 repo  |  40823219 site  |  40823222 repo  |  40823222 site  |  40823231-2 repo  |  40823231-2 site  |  40823244 repo |  40823244 site ---------- stage3-bg4 repo  |  stage3-bg4 site  |  40823239 repo  |  40823239 site  |  s40723140 repo  |  s40723140 site  |  s40723128 repo  |  s40723128 site  |  s40723139 repo  |  s40723139 site  |  s40723106 repo  |  s40723106 site  |  s40723135 repo  |  s40723135 site  |  s40723143 repo  |  s40723143 site  |  s40723215 repo |  s40723215 site ---------- stage3-bg5 repo  |  stage3-bg5 site  |  40823221 repo  |  40823221 site  |  40823204 repo  |  40823204 site  |  40823205 repo  |  40823205 site  |  40823220 repo  |  40823220 site  |  40823228 repo  |  40823228 site  |  40823237 repo  |  40823237 site  |  40823242 repo  |  40823242 site  |  40823250 repo |  40823250 site  |  40832244 repo |  40832244 site ---------- stage3-bg6 repo  |  stage3-bg6 site  |  40823225 repo  |  40823225 site  |  40823214 repo  |  40823214 site  |  40823218 repo  |  40823218 site  |  40823211 repo  |  40823211 site  |  40823248 repo  |  40823248 site  |  40823247 repo  |  40823247 site  |  40823216 repo  |  40823216 site  |  40823238 repo |  40823238 site ---------- stage3-bg7 repo  |  stage3-bg7 site  |  40623144 repo  |  40623144 site  |  40823233 repo  |  40823233 site  |  s40723224 repo  |  s40723224 site  |  40823241 repo  |  40823241 site  |  40423155 repo  |  40423155 site  |  40823227 repo  |  40823227 site  |  s40723233 repo  |  s40723233 site ---------- \n \n', 'tags': '', 'url': 'task1.html'}, {'title': '每週進度影片', 'text': '', 'tags': '', 'url': '每週進度影片.html'}, {'title': '第九週', 'text': '\n', 'tags': '', 'url': '第九週.html'}, {'title': '第十週', 'text': '\n', 'tags': '', 'url': '第十週.html'}, {'title': '第十一週', 'text': '\n', 'tags': '', 'url': '第十一週.html'}, {'title': '第十二週', 'text': '\n', 'tags': '', 'url': '第十二週.html'}, {'title': '第十三週', 'text': '\n', 'tags': '', 'url': '第十三週.html'}, {'title': '討論', 'text': '本小組的討論時間在組員的協調下，最終定為每個禮拜一的晚上11.。 \n', 'tags': '', 'url': '討論.html'}, {'title': 'discord', 'text': '邀請連結(按我) \n', 'tags': '', 'url': 'discord.html'}, {'title': '第一次討論', 'text': '4/27 \n \n \n', 'tags': '', 'url': '第一次討論.html'}, {'title': '第二次討論', 'text': '\n \n \n \n', 'tags': '', 'url': '第二次討論.html'}, {'title': '第三次討論', 'text': '\n \n \n', 'tags': '', 'url': '第三次討論.html'}, {'title': '第四次討論', 'text': '\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': '第四次討論.html'}, {'title': '第五次討論', 'text': '\n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': '第五次討論.html'}, {'title': '第六次討論', 'text': '\n \n', 'tags': '', 'url': '第六次討論.html'}, {'title': '第七次討論', 'text': '\n \n', 'tags': '', 'url': '第七次討論.html'}, {'title': '遇到的問題', 'text': '', 'tags': '', 'url': '遇到的問題.html'}, {'title': '更新出錯', 'text': '\n \n 參考網站: https://blog.csdn.net/yxlshk/article/details/79944535 \n 說明:由於兩位組員通時進行推動的動作，所以出現了有位組員pull時檔案衝突 ， 我們討論後決定將他的版本退回到上個版本，結果證實此方法可以有效解決這個問題。 \n', 'tags': '', 'url': '更新出錯.html'}, {'title': '倉儲帳號被鎖', 'text': '小組成員遇到帳號被github鎖掉的情況 \n \n 解決方式，用gitlab代替github，但兩邊都要push \n', 'tags': '', 'url': '倉儲帳號被鎖.html'}, {'title': 'github、gitlab不同步解決辦法', 'text': 'clone兩個倉儲，兩邊分開推 \n', 'tags': '', 'url': 'github、gitlab不同步解決辦法.html'}, {'title': '小組直播影片', 'text': '這邊放的是每週老師說要直播的影片 \n', 'tags': '', 'url': '小組直播影片.html'}, {'title': '第11週', 'text': '14號及18號拍攝 \n \n 16號拍攝 \n \n 25號拍攝 \n \n', 'tags': '', 'url': '第11週.html'}, {'title': '第12週', 'text': '14號及48號拍攝 \n \n 18號及11號所拍攝 \n \n', 'tags': '', 'url': '第12週.html'}, {'title': '第13週', 'text': '第一次 \n \n 第二次 \n \n', 'tags': '', 'url': '第13週.html'}, {'title': '第15週', 'text': '\n', 'tags': '', 'url': '第15週.html'}, {'title': 'W15', 'text': '', 'tags': '', 'url': 'W15.html'}, {'title': '影片字幕整理', 'text': '右下角可開啟字幕 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': '影片字幕整理.html'}]};